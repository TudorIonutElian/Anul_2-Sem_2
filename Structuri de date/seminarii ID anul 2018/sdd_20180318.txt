#include <iostream>

struct Carte {
	char* titlu;
	int nrPagini;
};
//nod pt lista secundara
struct nodDublu {
	nodDublu* next;
	nodDublu* prev;
	Carte info;
};

//nod pt lista principala
struct nodSimplu {
	nodSimplu* next;
	nodDublu* first;
	int nrMaximPagini;
};

Carte citesteCarte() {
	Carte carte; //creare carte
	char buffer[20];
	printf("Titlu:");
	scanf("%s", buffer);
	carte.titlu = (char*)malloc(sizeof(char)*strlen(buffer));//(strlen(buffer) + 1));
	strcpy(carte.titlu, buffer);

	printf("Nr pagini:");
	scanf("%d", &carte.nrPagini);

	return carte;
}

nodDublu* inserareListaDubla(nodDublu* first, Carte info) {
	//principiul de lucru cu coada, metoda de inserare la inceput coada 
	//stiva LIFO toate prelucrarile la acelasi capat ori inceput, ori sfarsit
	if (first) { //in primul rand verficam daca avem lista
		nodDublu* p = first;
		while (p->next) {//cat timp exista p next ne deplasam
			p = p->next;
		}
		nodDublu* nou = (nodDublu*)malloc(sizeof(nodDublu));
		nou->info.nrPagini = info.nrPagini;//facem shallow copy tb sa aloc spatiul
		nou->info.titlu = (char*)malloc(sizeof(char)*(strlen(info.titlu) + 1));
		strcpy(nou->info.titlu, info.titlu);
		nou->next = NULL;
		nou->prev = p;
		p->next = nou;
		return first;//iterare la sfarsit
}
	else {
		nodDublu* nou = (nodDublu*)malloc(sizeof(nodDublu));
		nou->info.nrPagini = info.nrPagini;//facem shallow copy tb sa aloc spatiul
		nou->info.titlu = (char*)malloc(sizeof(char)*(strlen(info.titlu) + 1));
		strcpy(nou->info.titlu, info.titlu);
		nou->next = NULL;
		nou->prev = NULL;
		return nou;
	}

}

nodSimplu* inserareListaPrincipala(nodSimplu* cap, Carte info) { //inserare in interior sortat
	if (cap) {
		//daca avem valoarea 100 inseram 0-99
		//200 - 100-199
		//dc scadem o suta si tot e mai mare decat nr pagini inseamna ca tb sa inseram inainte nodul
		if (cap->nrMaximPagini - 100 > info.nrPagini) {
			//e ca la inserare la inceput
			nodSimplu* nou = (nodSimplu*)malloc(sizeof(nodSimplu));
			nou->next = cap;
			nou->nrMaximPagini =(info.nrPagini/100 + 1) * 100;
			nou->first = NULL;
			nou->first = inserareListaDubla(nou->first, info);//nu e bine pt ca primul nod nu are val null si noi tb sa avem null, de aceea pun linia de dinainte
			return nou;
		}
		else {
			//parcurgem lista principala
			if (cap->nrMaximPagini > info.nrPagini) {
				cap->first = inserareListaDubla(cap->first, info);

			}
			else {
				nodSimplu* p = cap;
				while (p->next && p->next->nrMaximPagini < info.nrPagini) {
					p = p->next;
				}
				//dc ies pe p->next at fac inserare la sfarsit
				//dc ies pe p->next
				if (p->next) {
					if (p->next->nrMaximPagini - 100 < info.nrPagini) {
						//inseamna k tb sa mai introduc un nod - inserare la sfarsit
						p->next->first = inserareListaDubla(p->next->first, info);//pot sa folosesc notatia p->next = q si sa fol doar q mai departe
					}
					else {
						//inserare la mijloc
						nodSimplu* nou = (nodSimplu*)malloc(sizeof(nodSimplu));//intai creez nodul
						nou->nrMaximPagini = (info.nrPagini / 100 + 1) * 100;
						nou->next = p->next;
						p->next = nou;
						nou->first = NULL;
						nou->first = inserareListaDubla(nou->first, info);
					
				}
			}
	else {
		//inserare la sfarsit
		nodSimplu* nou = (nodSimplu*)malloc(sizeof(nodSimplu));//intai creez nodul
		nou->nrMaximPagini = (info.nrPagini / 100 + 1) * 100;
		nou->next = NULL;
		p->next = nou;
		nou->first = NULL;
		nou->first = inserareListaDubla(nou->first, info);
	}
		}
			return cap;
			}
		}
	else {
		//
		nodSimplu* nou = (nodSimplu*)malloc(sizeof(nodSimplu));//intai creez nodul
		nou->nrMaximPagini = (info.nrPagini / 100 + 1) * 100;
		nou->next = NULL;
		//p->next = nou; //NU EXISTA
		nou->first = NULL;
		nou->first = inserareListaDubla(nou->first, info);
		return nou;
	}
}

void afisareCarte(Carte carte) {
	printf("Cartea %s are %d pagini\n", carte.titlu, carte.nrPagini);
	}

void afisareListaDublu(nodDublu* first) {
	while (first) {
		afisareCarte(first->info);
		first = first->next;
	}
}

void afisareListaPrincipala(nodSimplu* cap) {
	while (cap) {
		afisareListaDublu(cap->first);
		cap = cap->next;
	}
}

nodDublu* stergereListaDubla(nodDublu* first) {
	while (first) {
		free(first->info.titlu);
		nodDublu*temp = first;
		first = first->next;
		free(temp);
	}
	return NULL;
}

nodSimplu* stergereListaPrincipala(nodSimplu* cap) {
	while (cap) {
		cap->first = stergereListaDubla(cap->first);
		nodSimplu* t = cap;
		cap = cap->next;
		free(t);
	}
	return cap;//care returneaza de fapt null

}

void main() {
		//lista de liste pp un nod, primul nod are previous null seamana cu un nod de la lista dubla
		//apel metoda
		nodSimplu* cap = NULL;
		cap = inserareListaPrincipala(cap, citesteCarte());
		cap = inserareListaPrincipala(cap, citesteCarte());
		cap = inserareListaPrincipala(cap, citesteCarte());
		cap = inserareListaPrincipala(cap, citesteCarte());

		afisareListaPrincipala(cap);
		cap = stergereListaPrincipala(cap);
}